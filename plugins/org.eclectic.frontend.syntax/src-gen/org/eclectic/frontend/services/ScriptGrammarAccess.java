/*
* generated by Xtext
*/

package org.eclectic.frontend.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclectic.frontend.syntax.services.ExpressionsGrammarAccess;

@Singleton
public class ScriptGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ScriptedTransformationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ScriptedTransformation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cScriptKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInModelsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInModelsTransformationDefinitionParameterParserRuleCall_3_0 = (RuleCall)cInModelsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cOutModelsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cOutModelsTransformationDefinitionParameterParserRuleCall_7_0 = (RuleCall)cOutModelsAssignment_7.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cStatementsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cStatementsStatementParserRuleCall_9_0 = (RuleCall)cStatementsAssignment_9.eContents().get(0);
		
		////import "platform:/resource/modelum.eclectic.compiler/model/family/eclectic.frontend.ecore#//frontend" as frontend
		//ScriptedTransformation returns script::ScriptedTransformation:
		//	"script" name=EString // '(' left=[core::TransformationDefinitionParameter|EString] ')'
		//	//'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
		//	"(" inModels+=TransformationDefinitionParameter ")" "->" "(" outModels+=TransformationDefinitionParameter ")" // like this to resolve a reference: it is not the case
		//	//'(' right=[core::TransformationDefinitionParameter|EString] ')'
		//	// ('annotations' '{' annotations+=Annotation ( "," annotations+=Annotation)* '}' )?
		//	//('inModels' '{' inModels+=TransformationDefinitionParameter ( "," inModels+=TransformationDefinitionParameter)* '}' )?
		//	// ('outModels' '{' outModels+=TransformationDefinitionParameter ( "," outModels+=TransformationDefinitionParameter)* '}' )?
		//
		//	// (traceInterface = TraceInterface)?	
		//	statements+=Statement+;
		public ParserRule getRule() { return rule; }

		//"script" name=EString // '(' left=[core::TransformationDefinitionParameter|EString] ')'
		////'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
		//"(" inModels+=TransformationDefinitionParameter ")" "->" "(" outModels+=TransformationDefinitionParameter ")" // like this to resolve a reference: it is not the case
		////'(' right=[core::TransformationDefinitionParameter|EString] ')'
		//// ('annotations' '{' annotations+=Annotation ( "," annotations+=Annotation)* '}' )?
		////('inModels' '{' inModels+=TransformationDefinitionParameter ( "," inModels+=TransformationDefinitionParameter)* '}' )?
		//// ('outModels' '{' outModels+=TransformationDefinitionParameter ( "," outModels+=TransformationDefinitionParameter)* '}' )?
		//// (traceInterface = TraceInterface)?	
		//statements+=Statement+
		public Group getGroup() { return cGroup; }

		//"script"
		public Keyword getScriptKeyword_0() { return cScriptKeyword_0; }

		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }

		//// '(' left=[core::TransformationDefinitionParameter|EString] ')'
		////'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//inModels+=TransformationDefinitionParameter
		public Assignment getInModelsAssignment_3() { return cInModelsAssignment_3; }

		//TransformationDefinitionParameter
		public RuleCall getInModelsTransformationDefinitionParameterParserRuleCall_3_0() { return cInModelsTransformationDefinitionParameterParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_5() { return cHyphenMinusGreaterThanSignKeyword_5; }

		//"("
		public Keyword getLeftParenthesisKeyword_6() { return cLeftParenthesisKeyword_6; }

		//outModels+=TransformationDefinitionParameter
		public Assignment getOutModelsAssignment_7() { return cOutModelsAssignment_7; }

		//TransformationDefinitionParameter
		public RuleCall getOutModelsTransformationDefinitionParameterParserRuleCall_7_0() { return cOutModelsTransformationDefinitionParameterParserRuleCall_7_0; }

		//")"
		public Keyword getRightParenthesisKeyword_8() { return cRightParenthesisKeyword_8; }

		//statements+=Statement+
		public Assignment getStatementsAssignment_9() { return cStatementsAssignment_9; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_9_0() { return cStatementsStatementParserRuleCall_9_0; }
	}

	public class TransformationDefinitionParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TransformationDefinitionParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTransformationDefinitionParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// @common
		//TransformationDefinitionParameter returns core::TransformationDefinitionParameter:
		//	{core::TransformationDefinitionParameter} name=EString;
		public ParserRule getRule() { return rule; }

		//{core::TransformationDefinitionParameter} name=EString
		public Group getGroup() { return cGroup; }

		//{core::TransformationDefinitionParameter}
		public Action getTransformationDefinitionParameterAction_0() { return cTransformationDefinitionParameterAction_0; }

		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
	}
	
	
	private ScriptedTransformationElements pScriptedTransformation;
	private TransformationDefinitionParameterElements pTransformationDefinitionParameter;
	
	private final GrammarProvider grammarProvider;

	private ExpressionsGrammarAccess gaExpressions;

	@Inject
	public ScriptGrammarAccess(GrammarProvider grammarProvider,
		ExpressionsGrammarAccess gaExpressions) {
		this.grammarProvider = grammarProvider;
		this.gaExpressions = gaExpressions;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public ExpressionsGrammarAccess getExpressionsGrammarAccess() {
		return gaExpressions;
	}

	
	////import "platform:/resource/modelum.eclectic.compiler/model/family/eclectic.frontend.ecore#//frontend" as frontend
	//ScriptedTransformation returns script::ScriptedTransformation:
	//	"script" name=EString // '(' left=[core::TransformationDefinitionParameter|EString] ')'
	//	//'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
	//	"(" inModels+=TransformationDefinitionParameter ")" "->" "(" outModels+=TransformationDefinitionParameter ")" // like this to resolve a reference: it is not the case
	//	//'(' right=[core::TransformationDefinitionParameter|EString] ')'
	//	// ('annotations' '{' annotations+=Annotation ( "," annotations+=Annotation)* '}' )?
	//	//('inModels' '{' inModels+=TransformationDefinitionParameter ( "," inModels+=TransformationDefinitionParameter)* '}' )?
	//	// ('outModels' '{' outModels+=TransformationDefinitionParameter ( "," outModels+=TransformationDefinitionParameter)* '}' )?
	//
	//	// (traceInterface = TraceInterface)?	
	//	statements+=Statement+;
	public ScriptedTransformationElements getScriptedTransformationAccess() {
		return (pScriptedTransformation != null) ? pScriptedTransformation : (pScriptedTransformation = new ScriptedTransformationElements());
	}
	
	public ParserRule getScriptedTransformationRule() {
		return getScriptedTransformationAccess().getRule();
	}

	//// @common
	//TransformationDefinitionParameter returns core::TransformationDefinitionParameter:
	//	{core::TransformationDefinitionParameter} name=EString;
	public TransformationDefinitionParameterElements getTransformationDefinitionParameterAccess() {
		return (pTransformationDefinitionParameter != null) ? pTransformationDefinitionParameter : (pTransformationDefinitionParameter = new TransformationDefinitionParameterElements());
	}
	
	public ParserRule getTransformationDefinitionParameterRule() {
		return getTransformationDefinitionParameterAccess().getRule();
	}

	//// Begin-of Core
	//TraceInterface returns core::TraceInterface:
	//	"trace" name=EString definitions+=TraceDefinition+ "end";
	public ExpressionsGrammarAccess.TraceInterfaceElements getTraceInterfaceAccess() {
		return gaExpressions.getTraceInterfaceAccess();
	}
	
	public ParserRule getTraceInterfaceRule() {
		return getTraceInterfaceAccess().getRule();
	}

	//TraceDefinition returns core::TraceDefinition:
	//	"link" name=EString ("{" elements+=TraceElementInline (";" elements+=TraceElementInline)* "}" |
	//	elements+=TraceElementExpanded elements+=TraceElementExpanded* "end");
	public ExpressionsGrammarAccess.TraceDefinitionElements getTraceDefinitionAccess() {
		return gaExpressions.getTraceDefinitionAccess();
	}
	
	public ParserRule getTraceDefinitionRule() {
		return getTraceDefinitionAccess().getRule();
	}

	//TraceElementInline returns core::TraceElement:
	//	name=EString ":" type=TypeExpression;
	public ExpressionsGrammarAccess.TraceElementInlineElements getTraceElementInlineAccess() {
		return gaExpressions.getTraceElementInlineAccess();
	}
	
	public ParserRule getTraceElementInlineRule() {
		return getTraceElementInlineAccess().getRule();
	}

	//TraceElementExpanded returns core::TraceElement:
	//	"var" name=EString ":" type=TypeExpression;
	public ExpressionsGrammarAccess.TraceElementExpandedElements getTraceElementExpandedAccess() {
		return gaExpressions.getTraceElementExpandedAccess();
	}
	
	public ParserRule getTraceElementExpandedRule() {
		return getTraceElementExpandedAccess().getRule();
	}

	//TypeExpression returns core::TypeExpression:
	//	ClassUse;
	public ExpressionsGrammarAccess.TypeExpressionElements getTypeExpressionAccess() {
		return gaExpressions.getTypeExpressionAccess();
	}
	
	public ParserRule getTypeExpressionRule() {
		return getTypeExpressionAccess().getRule();
	}

	//ClassUse returns core::ClassUse:
	//	model=[core::RepresentModel] "!" className=ID;
	public ExpressionsGrammarAccess.ClassUseElements getClassUseAccess() {
		return gaExpressions.getClassUseAccess();
	}
	
	public ParserRule getClassUseRule() {
		return getClassUseAccess().getRule();
	}

	//Statement returns core::Statement:
	//	DefineVariable | Expression | PutTraceExpression | PropertyWrite;
	public ExpressionsGrammarAccess.StatementElements getStatementAccess() {
		return gaExpressions.getStatementAccess();
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//PropertyWrite returns core::PropertyWrite:
	//	receptor=[core::Variable] "." property=ID "=" expression=Expression;
	public ExpressionsGrammarAccess.PropertyWriteElements getPropertyWriteAccess() {
		return gaExpressions.getPropertyWriteAccess();
	}
	
	public ParserRule getPropertyWriteRule() {
		return getPropertyWriteAccess().getRule();
	}

	//DefineVariable returns core::DefineVariable:
	//	name=EString "=" expression=Expression;
	public ExpressionsGrammarAccess.DefineVariableElements getDefineVariableAccess() {
		return gaExpressions.getDefineVariableAccess();
	}
	
	public ParserRule getDefineVariableRule() {
		return getDefineVariableAccess().getRule();
	}

	//// ClassUse How to reuse ClassUse?? 
	//ModelReference returns core::ModelReference:
	//	model=[core::RepresentModel] "!" className=EString;
	public ExpressionsGrammarAccess.ModelReferenceElements getModelReferenceAccess() {
		return gaExpressions.getModelReferenceAccess();
	}
	
	public ParserRule getModelReferenceRule() {
		return getModelReferenceAccess().getRule();
	}

	//Expression returns core::Expression:
	//	MethodCall;
	public ExpressionsGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaExpressions.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// should be in another language?
	////| BinaryExpr
	//PrimaryExpression returns core::Expression:
	//	Literal | VariableReference | ModelReference | ParenthesizedExpression | MatchTraceExpression | ClosureDeclaration;
	public ExpressionsGrammarAccess.PrimaryExpressionElements getPrimaryExpressionAccess() {
		return gaExpressions.getPrimaryExpressionAccess();
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	////BinaryExpr returns core::BinaryExpr:
	////	left=Expression  binaryOp=BinaryOp right=Expression 
	////;
	//enum BinaryOp returns core::BinaryOp:
	//	ADD="+" | SUB="-" | MUL="*" | DIV="/";
	public ExpressionsGrammarAccess.BinaryOpElements getBinaryOpAccess() {
		return gaExpressions.getBinaryOpAccess();
	}
	
	public EnumRule getBinaryOpRule() {
		return getBinaryOpAccess().getRule();
	}

	//ParenthesizedExpression returns core::Expression:
	//	"(" Expression ")";
	public ExpressionsGrammarAccess.ParenthesizedExpressionElements getParenthesizedExpressionAccess() {
		return gaExpressions.getParenthesizedExpressionAccess();
	}
	
	public ParserRule getParenthesizedExpressionRule() {
		return getParenthesizedExpressionAccess().getRule();
	}

	//Literal returns core::Expression:
	//	FloatLiteral | NumLiteral | StringLiteral;
	public ExpressionsGrammarAccess.LiteralElements getLiteralAccess() {
		return gaExpressions.getLiteralAccess();
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//VariableReference returns core::VariableReference:
	//	variable=[core::Variable];
	public ExpressionsGrammarAccess.VariableReferenceElements getVariableReferenceAccess() {
		return gaExpressions.getVariableReferenceAccess();
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}

	//ClosureDeclaration returns core::ClosureDeclaration:
	//	"{" ("|" formalParameters+=ClosureParameter ("," formalParameters+=ClosureParameter)* "|")? statements+=Statement+
	//	"}";
	public ExpressionsGrammarAccess.ClosureDeclarationElements getClosureDeclarationAccess() {
		return gaExpressions.getClosureDeclarationAccess();
	}
	
	public ParserRule getClosureDeclarationRule() {
		return getClosureDeclarationAccess().getRule();
	}

	//ClosureParameter returns core::ClosureParameter:
	//	name=ID;
	public ExpressionsGrammarAccess.ClosureParameterElements getClosureParameterAccess() {
		return gaExpressions.getClosureParameterAccess();
	}
	
	public ParserRule getClosureParameterRule() {
		return getClosureParameterAccess().getRule();
	}

	//MethodCall returns core::Expression:
	//	PrimaryExpression ({core::BinaryExpr.left=current} binaryOp=BinaryOp right=Expression //|	( ({core::MethodCall.receptor = current}) "." methodName=EString )
	//	//|   (=> ({core::KeywordMethodCall.receptor = current}) "." (parameters+=KeywordParameter)+  )
	//	//|   (=> ({core::KeywordMethodCall.receptor = current}) (parameters+=KeywordParameter)+  )+	
	//	| (=> ({core::MethodCall.receptor=current}) "." methodName=EString (withParameters?="(" parameters+=Expression (","
	//	parameters+=Expression)* ")")? parameters+=ClosureDeclaration?)+)?;
	public ExpressionsGrammarAccess.MethodCallElements getMethodCallAccess() {
		return gaExpressions.getMethodCallAccess();
	}
	
	public ParserRule getMethodCallRule() {
		return getMethodCallAccess().getRule();
	}

	//WithResolveMethodCall returns core::Expression:
	//	PrimaryExpression ({core::BinaryExpr.left=current} binaryOp=BinaryOp right=Expression // to allow accessing attributes	
	//	| (({core::ResolveLink.expr=current} "[" (module=[core::UseDeclaration] isExternal?="!")? linkName=EString ("."
	//	featureName=EString)? "]") (=> ({core::MethodCall.receptor=current}) "." methodName=EString (withParameters?="("
	//	parameters+=Expression ("," parameters+=Expression)* ")")? parameters+=ClosureDeclaration?)?)+ | ((=>
	//	({core::MethodCall.receptor=current}) "." methodName=EString (withParameters?="(" parameters+=Expression (","
	//	parameters+=Expression)* ")")? parameters+=ClosureDeclaration?) ({core::ResolveLink.expr=current} "["
	//	(module=[core::UseDeclaration] isExternal?="!")? linkName=EString ("." featureName=EString)? "]")?)+)? // ? ( ({attr::AttributeUse.expr = current}) "[" attribute=[attr::AttributeDcl] "]" )?
	//;
	public ExpressionsGrammarAccess.WithResolveMethodCallElements getWithResolveMethodCallAccess() {
		return gaExpressions.getWithResolveMethodCallAccess();
	}
	
	public ParserRule getWithResolveMethodCallRule() {
		return getWithResolveMethodCallAccess().getRule();
	}

	/// *
	//WithResolveMethodCall returns core::Expression:
	//	PrimaryExpression
	//	(
	//		( ({core::BinaryExpr.left = current}) binaryOp=BinaryOp right=Expression)		
	//		| ( ( ({core::ResolveLink.expr = current}) "[" linkName=EString "]" )
	//			(=> ({core::MethodCall.receptor = current}) "." methodName=EString (withParameters?="(" parameters+=Expression ("," parameters+=Expression)* ")" )? (parameters+=ClosureDeclaration)?  )?
	//			)+
	//	    | ( (=> ({core::MethodCall.receptor = current}) "." methodName=EString (withParameters?="(" parameters+=Expression ("," parameters+=Expression)* ")" )? (parameters+=ClosureDeclaration)?  )
	//			  (({core::ResolveLink.expr = current}) "[" linkName=EString "]")? )+
	//        // to allow accessing attributes	
	//	)? // ? ( ({attr::AttributeUse.expr = current}) "[" attribute=[attr::AttributeDcl] "]" )?
	//;
	// * / / *
	//class ResolveLink extends Expression {
	//   val Expression[1] expr;
	//   attr Boolean[1] isExternal = false;
	//   ref UseDeclaration[0..1] module;
	//
	//   attr String[1] linkName;
	//   attr String[0..1] featureName;
	//}
	// * / KeywordParameter returns core::KeywordParameter:
	//	keyword=KEYWORD_ID value=Expression;
	public ExpressionsGrammarAccess.KeywordParameterElements getKeywordParameterAccess() {
		return gaExpressions.getKeywordParameterAccess();
	}
	
	public ParserRule getKeywordParameterRule() {
		return getKeywordParameterAccess().getRule();
	}

	//terminal KEYWORD_ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")* ":";
	public TerminalRule getKEYWORD_IDRule() {
		return gaExpressions.getKEYWORD_IDRule();
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaExpressions.getIDRule();
	} 

	//MatchTraceExpression returns core::MatchTrace:
	//	"match" (ID "!")? trace=[core::TraceDefinition] "with" "[" traceExpr=TraceExprLanguage "]";
	public ExpressionsGrammarAccess.MatchTraceExpressionElements getMatchTraceExpressionAccess() {
		return gaExpressions.getMatchTraceExpressionAccess();
	}
	
	public ParserRule getMatchTraceExpressionRule() {
		return getMatchTraceExpressionAccess().getRule();
	}

	//// TODO: Resolve!! 
	//TraceExprLanguage returns core::TraceCompareExpression:
	//	traceVar=[core::TraceElement] "=" expr=Expression;
	public ExpressionsGrammarAccess.TraceExprLanguageElements getTraceExprLanguageAccess() {
		return gaExpressions.getTraceExprLanguageAccess();
	}
	
	public ParserRule getTraceExprLanguageRule() {
		return getTraceExprLanguageAccess().getRule();
	}

	//PutTraceExpression returns core::PutTrace:
	//	"put" (ID "!")? trace=[core::TraceDefinition] "with" "[" parameters+=PutTraceParameter (","
	//	parameters+=PutTraceParameter)+ "]";
	public ExpressionsGrammarAccess.PutTraceExpressionElements getPutTraceExpressionAccess() {
		return gaExpressions.getPutTraceExpressionAccess();
	}
	
	public ParserRule getPutTraceExpressionRule() {
		return getPutTraceExpressionAccess().getRule();
	}

	//PutTraceParameter returns core::PutTraceParameter:
	//	traceVar=[core::TraceElement] "=" value=Expression;
	public ExpressionsGrammarAccess.PutTraceParameterElements getPutTraceParameterAccess() {
		return gaExpressions.getPutTraceParameterAccess();
	}
	
	public ParserRule getPutTraceParameterRule() {
		return getPutTraceParameterAccess().getRule();
	}

	/// *
	//MethodCall returns core::MethodCall:
	//	receptor=Expression "." methodName=EString
	//	("(" parameters+=Expression ("," parameters+=Expression)* ")")?
	//; 
	// * / / *
	// 
	// => indica precedencia
	//XMemberFeatureCall returns XExpression:
	//        XPrimaryExpression
	//        (=>({XAssignment.assignable=current} '.' feature=[types::JvmIdentifiableElement|ValidID] OpSingleAssign) value=XAssignment
	//        |=>({XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|spreading?="*.")) 
	//                ('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
	//                feature=[types::JvmIdentifiableElement|ValidID] (
	//                        =>explicitOperationCall?='(' 
	//                                (
	//                                    memberCallArguments+=XShortClosure
	//                                  |     memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
	//                                )? 
	//                        ')')?
	//                )*;
	//
	//XPrimaryExpression returns XExpression:
	//        XConstructorCall |
	//        XBlockExpression |
	//        XSwitchExpression |
	//        XFeatureCall |
	//        XLiteral |
	//        XIfExpression |
	//        XForLoopExpression |
	//        XWhileExpression |
	//        XDoWhileExpression |
	//        XThrowExpression |
	//        XReturnExpression |
	//        XTryCatchFinallyExpression |
	//        XParenthesizedExpression;
	// * / NumLiteral returns core::NumLiteral:
	//	value=EInt;
	public ExpressionsGrammarAccess.NumLiteralElements getNumLiteralAccess() {
		return gaExpressions.getNumLiteralAccess();
	}
	
	public ParserRule getNumLiteralRule() {
		return getNumLiteralAccess().getRule();
	}

	//FloatLiteral returns core::DoubleLiteral:
	//	value=EDouble;
	public ExpressionsGrammarAccess.FloatLiteralElements getFloatLiteralAccess() {
		return gaExpressions.getFloatLiteralAccess();
	}
	
	public ParserRule getFloatLiteralRule() {
		return getFloatLiteralAccess().getRule();
	}

	//EDouble returns ecore::EDouble:
	//	INT "." INT;
	public ExpressionsGrammarAccess.EDoubleElements getEDoubleAccess() {
		return gaExpressions.getEDoubleAccess();
	}
	
	public ParserRule getEDoubleRule() {
		return getEDoubleAccess().getRule();
	}

	//StringLiteral returns core::StringLiteral:
	//	value=STRING;
	public ExpressionsGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaExpressions.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//// End-of Core
	//EString returns ecore::EString:
	//	STRING | ID;
	public ExpressionsGrammarAccess.EStringElements getEStringAccess() {
		return gaExpressions.getEStringAccess();
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}

	//EInt returns ecore::EInt:
	//	"-"? INT;
	public ExpressionsGrammarAccess.EIntElements getEIntAccess() {
		return gaExpressions.getEIntAccess();
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaExpressions.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaExpressions.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaExpressions.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaExpressions.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaExpressions.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaExpressions.getANY_OTHERRule();
	} 
}

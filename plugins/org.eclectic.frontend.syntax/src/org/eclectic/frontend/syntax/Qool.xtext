// automatically generated by Xtext
grammar org.eclectic.frontend.Qool with org.eclectic.frontend.syntax.Expressions

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//core" as core

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//qool" as qool
import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//qool/facilities" as facilities

//import "platform:/resource/modelum.eclectic.compiler/model/family/eclectic.frontend.ecore#//frontend" as frontend

QoolTransformation returns qool::QoolTransformation:
	'qool'
	name=EString
	// '(' left=[core::TransformationDefinitionParameter|EString] ')'
	//'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
	'(' inModels+=TransformationDefinitionParameter ("," inModels+=TransformationDefinitionParameter)* ')'
	'->'
	'(' (outModels+=TransformationDefinitionParameter ("," outModels+=TransformationDefinitionParameter)*)? ')'
		(annotations+=Annotation)*
	// like this to resolve a reference: it is not the case
	//'(' right=[core::TransformationDefinitionParameter|EString] ')'
		// ('annotations' '{' annotations+=Annotation ( "," annotations+=Annotation)* '}' )?
		//('inModels' '{' inModels+=TransformationDefinitionParameter ( "," inModels+=TransformationDefinitionParameter)* '}' )?
		// ('outModels' '{' outModels+=TransformationDefinitionParameter ( "," outModels+=TransformationDefinitionParameter)* '}' )?
	// (traceInterface = TraceInterface)
	(inlineModels += InlineModel)*
	(importedModels+=ImportedModel)*
	(queues += QoolQueue)+
	(segments += Segment)+
    ;

// This is to allow serialization...
ImportedModel returns core::ImportedModel: 
	"imported" name=EString
;


// @common
Annotation returns core::Annotation:
	MetamodelModelAnnotation
;

MetamodelModelAnnotation returns core::MetamodelModelAnnotation:
	annotatedElement=[core::RepresentModel] ":" metamodel=STRING
;

TransformationDefinitionParameter returns core::TransformationDefinitionParameter:
	{core::TransformationDefinitionParameter}
	name=EString
	;

InlineModel returns core::InlineModel :
	"model" name=EString
		(classes+=InlineClass)+
	"end"
;

InlineClass returns core::InlineClass :
	"class" name=EString	 
	(('{' features+=InlineReferenceInline ( ";" features+=InlineReferenceInline)* '}') | 
     ( features+=InlineFeatureExpanded ( features+=InlineFeatureExpanded)* 'end'))
;

InlineReferenceInline returns core::InlineReference:
	name=EString ":" type=TypeExpression
;

InlineFeatureExpanded returns core::InlineFeature :
	InlineAttributeExpanded 
	| InlineReferenceExpanded
;

InlineAttributeExpanded returns core::InlineAttribute :
	"att" name=EString  ":" type=TypeExpression (multivalued?="*")? 
;

InlineReferenceExpanded returns core::InlineReference:
	"ref" name=EString ":" type=TypeExpression (multivalued?="*")?
;

// -- Queue 
QoolQueue returns qool::QoolQueue:
	LocalQueue |
	ModelElementQueue
;

LocalQueue returns qool::LocalQueue:
	"local" "queue" name=ID ":" type_=TypeExpression ("with" (optimizations+=QueueOptimization)+) ?
;

ModelElementQueue returns qool::ModelElementQueue: 
	"model" "queue" name=ID ":" class_=ClassUse ("," additionals+=ClassUse)*
;

QueueOptimization returns qool::QueueOptimization: 
	AccessByFeatureOptimization
;

AccessByFeatureOptimization returns qool::AccessByFeatureOptimization: 
	"access-by" featureName=EString (force?="!")?
;



// -- Segments and expressions

Segment returns qool::Segment: 
	"segment" name=EString
		(statements += Statement)+	
	"end"	
;

// redefine
Statement returns core::Statement: 
	DefineVariable
	| Expression
	| PutTraceExpression
	| PropertyWrite
	| ForAllStatement
	// | ForEachStatement
	| EmitStatement	
	

;

// redefine
PrimaryExpression returns core::Expression: 
	  Literal
	| VariableReference
	| ModelReference
	| ParenthesizedExpression
	| MatchTraceExpression 
	| ClosureDeclaration
	| MatchExpression // <-- added for qool
    | InvokeTransformation

	// Facilities
	| Copier

;


NamedInvocationParameter returns qool::NamedInvocationParameter: 
	formalName=EString "=" actualParameter=Expression
;

InvokeTransformation returns qool::InvokeTransformation:
	  InvokeExternal	
	| InvokeInternal
;

InvokeInternal returns qool::InvokeInternal: 
	"invoke-internal" transformationName=QualifiedName
		"(" (sourceModels+=InvocationParameter (","  sourceModels+=InvocationParameter)*) ? ")" "->"
		"(" (targetModels+=InvocationParameter (","  targetModels+=InvocationParameter)*) ? ")"
			("input-view-filter" inputViewFilter=[core::DefineVariable])?
			("entrypoint" entryPointName=ID "(" (entryPointParameters+=Expression)?  ("," entryPointParameters+=Expression)* ")") ?
;

InvokeExternal returns qool::InvokeExternal: 
	"invoke-external" transformationName=QualifiedName
		"(" (sourceModels+=InvocationParameter (","  sourceModels+=InvocationParameter)*) ? ")" "->"
		"(" (targetModels+=InvocationParameter (","  targetModels+=InvocationParameter)*) ? ")"
		("+" "(" parameters+=NamedInvocationParameter ("," parameters+=NamedInvocationParameter)* ")" )?
	(
		(
			"entrypoint" entryPointName=ID "(" (entryPointParameters+=Expression)?  ("," entryPointParameters+=Expression)* ")") ?
	|   (
			"input-view-filter" inputViewFilter=[core::DefineVariable]
			("output-element"    outputResolutionSourceElement=Expression "[" queueName=EString "." traceAttributeName=EString "]")?
		)
	)
;

InvocationParameter returns qool::InvocationParameter: 
	calleeModelName=ID "=" model=[core::TransformationDefinitionParameter]  
;



ForAllStatement returns qool::ForAllStatement: 
	"forall" name=ID "from" queue=[qool::QoolQueue]
		("where" condition = Expression)?
		(statements += Statement)+		
	"end"
;

EmitStatement returns qool::EmitStatement: 
	"emit" value=Expression "to" queue=[qool::QoolQueue]
;

MatchExpression returns qool::MatchExpression: 
	queue=[qool::QoolQueue] "[" (predicates += Predicate) ("," predicates += Predicate)* "]" 
;

Predicate returns qool::MatchPredicate:
	KindOfPredicate
	| PropertyEqualsPredicate 
;

KindOfPredicate returns qool::KindOfPredicate:
    "#kindOf" "(" class_ = ClassUse ")"
;

PropertyEqualsPredicate returns qool::PropertyEqualsPredicate:
    "#p" "(" propertyName=EString "," value=Expression ")"
;

// Begin-of Facilities

Copier returns facilities::Copier: 
	"copy" "(" objects+=Expression ("," objects+=Expression)* ")" "model" copyInModel=[core::TransformationDefinitionParameter] ("{"
	   callbacks+=CopierCallbackDefinition ("," callbacks+=CopierCallbackDefinition)*
	"}")?
;

CopierCallbackDefinition returns facilities::CopierCallbackDefinition: 
	("with" | stop?="stop") trigger=Expression "->" action=Expression
;


// End-of facilities
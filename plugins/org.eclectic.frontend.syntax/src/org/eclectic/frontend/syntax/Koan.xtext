// automatically generated by Xtext
grammar org.eclectic.frontend.Koan with org.eclipse.xtext.common.Terminals 

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//core" as core

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//koan" as koan

//import "platform:/resource/modelum.eclectic.compiler/model/family/eclectic.frontend.ecore#//frontend" as frontend

MappingTransformation returns koan::KoanTransformation:
	'koan'
	name=EString
	// '(' left=[core::TransformationDefinitionParameter|EString] ')'
	//'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
	'(' (inModels+=TransformationDefinitionParameter) ')'
	'->'
	'(' outModels+=TransformationDefinitionParameter ')'
	
	// like this to resolve a reference: it is not the case
	//'(' right=[core::TransformationDefinitionParameter|EString] ')'
		// ('annotations' '{' annotations+=Annotation ( "," annotations+=Annotation)* '}' )?
		//('inModels' '{' inModels+=TransformationDefinitionParameter ( "," inModels+=TransformationDefinitionParameter)* '}' )?
		// ('outModels' '{' outModels+=TransformationDefinitionParameter ( "," outModels+=TransformationDefinitionParameter)* '}' )?
	(traceInterface = TraceInterface)
	(rules += KoanRule)+
    ;


 TransformationDefinitionParameter returns core::TransformationDefinitionParameter:
	{core::TransformationDefinitionParameter}
	name=EString
	;

// Begin-of Core
TraceInterface returns core::TraceInterface :
	"trace" name=EString
		(definitions+=TraceDefinition)+
	"end"
;

TraceDefinition returns core::TraceDefinition :
	"link" name=EString	 
	(('{' elements+=TraceElementInline ( ";" elements+=TraceElementInline)* '}') | 
     ( elements+=TraceElementExpanded ( elements+=TraceElementExpanded)* 'end'))
;

TraceElementInline returns core::TraceElement :
	name=EString ":" type=TypeExpression
;

TraceElementExpanded returns core::TraceElement :
	"var" name=EString ":" type=TypeExpression
;

TypeExpression returns core::TypeExpression:
	ClassUse
;

ClassUse returns core::ClassUse :
	model=[core::RepresentModel] "!" className=EString	
;

Statement returns core::Statement: 
	DefineVariable
	| Expression
	| PutTraceExpression
	| PropertyWrite
;

PropertyWrite returns core::PropertyWrite: 
	receptor=[core::Variable] "." property=ID "=" expression=Expression
;


DefineVariable returns core::DefineVariable: 
	name=EString "=" expression=Expression
;

ModelReference returns core::ModelReference:
	model=[core::RepresentModel] "!" className=EString	 
	// ClassUse How to reuse ClassUse?? 
;


Expression returns core::Expression:
	MethodCall	
;

PrimaryExpression returns core::Expression: 
	  Literal
	| VariableReference
	| ModelReference
	| ParenthesizedExpression
	| MatchTraceExpression 
	| ClosureDeclaration
	 // should be in another language?
	//| BinaryExpr
;

//BinaryExpr returns core::BinaryExpr:
//	left=Expression  binaryOp=BinaryOp right=Expression 
//;

enum BinaryOp returns core::BinaryOp: 
    ADD ='+'
  | SUB ='-'	
  | MUL= '*'	
  | DIV ='/'	
;

ParenthesizedExpression returns core::Expression:
  "(" Expression ")"
;

Literal returns core::Expression:
	NumLiteral 	
;

VariableReference returns core::VariableReference:
	variable=[core::Variable] 
;

ClosureDeclaration returns core::ClosureDeclaration: 
	"{" ("|" formalParameters+=ClosureParameter ( "," formalParameters+=ClosureParameter)* "|")?
	   (statements += Statement)+ "}"
;

ClosureParameter returns core::ClosureParameter: 
	name = ID
;



MethodCall returns core::Expression:
	PrimaryExpression
	(
		( ({core::BinaryExpr.left = current}) binaryOp=BinaryOp right=Expression)
	|	(=> ({core::MethodCall.receptor = current}) "." methodName=EString (withParameters?="(" parameters+=Expression ("," parameters+=Expression)* ")" )? )+
	|   ( ({core::KeywordMethodCall.receptor = current}) "." (parameters+=KeywordParameter)+  )
	)?
;

KeywordParameter returns core::KeywordParameter:
	keyword=KEYWORD_ID value=Expression 
;

terminal KEYWORD_ID : 
  ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ':'; 

terminal ID : 
  ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 

MatchTraceExpression returns core::MatchTrace:
	"match" (ID "!")? trace=[core::TraceDefinition] "with" "["
		traceExpr=TraceExprLanguage  "]"
;

TraceExprLanguage returns core::TraceCompareExpression:
	traceVar=[core::TraceElement] "=" (expr=Expression) 
	// TODO: Resolve!! 
;

PutTraceExpression returns core::PutTrace:
	"put" (ID "!")? trace=[core::TraceDefinition] "with" "["
		parameters+=PutTraceParameter ("," parameters+=PutTraceParameter)+  "]"
;

PutTraceParameter returns core::PutTraceParameter:
	traceVar=[core::TraceElement] "=" (value=Expression) 
;


    

/*
MethodCall returns core::MethodCall:
	receptor=Expression "." methodName=EString
	("(" parameters+=Expression ("," parameters+=Expression)* ")")?
; 
*/

/*
 
 => indica precedencia
XMemberFeatureCall returns XExpression:
        XPrimaryExpression
        (=>({XAssignment.assignable=current} '.' feature=[types::JvmIdentifiableElement|ValidID] OpSingleAssign) value=XAssignment
        |=>({XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|spreading?="*.")) 
                ('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
                feature=[types::JvmIdentifiableElement|ValidID] (
                        =>explicitOperationCall?='(' 
                                (
                                    memberCallArguments+=XShortClosure
                                  |     memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
                                )? 
                        ')')?
                )*;

XPrimaryExpression returns XExpression:
        XConstructorCall |
        XBlockExpression |
        XSwitchExpression |
        XFeatureCall |
        XLiteral |
        XIfExpression |
        XForLoopExpression |
        XWhileExpression |
        XDoWhileExpression |
        XThrowExpression |
        XReturnExpression |
        XTryCatchFinallyExpression |
        XParenthesizedExpression;
*/

NumLiteral returns core::NumLiteral:
	value=EInt 
;
// End-of Core

KoanRule returns koan::KoanRule:
	'rule' name=EString 
		matcher=Matcher
		(statements += Statement)+
	'end'
;

Matcher returns koan::Matcher:
	ForAllMatcher
;

ForAllMatcher returns koan::ForAllMatcher: 
	"forAll" name=ID ":" type=ClassUse 
	(child=Matcher)?
;


EString returns ecore::EString:
	STRING | ID;

EInt returns ecore::EInt:
	'-'? INT;


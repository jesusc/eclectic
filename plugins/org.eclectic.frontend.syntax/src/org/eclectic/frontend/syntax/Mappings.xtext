
// automatically generated by Xtext
grammar org.eclectic.frontend.Mappings // with org.eclectic.frontend.syntax.Expressions 
	with org.eclipse.xtext.common.Terminals 
    // with org.eclectic.frontend.syntax.Expressions

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//core" as core

import "platform:/resource/org.eclectic.frontend.asm/model/eclectic.frontend.ecore#//mappings" as mappings

//import "platform:/resource/modelum.eclectic.compiler/model/family/eclectic.frontend.ecore#//frontend" as frontend

MappingTransformation returns mappings::MappingTransformation:
	'mappings'
	name=EString
	// '(' left=[core::TransformationDefinitionParameter|EString] ')'
	//'(' (inModels+=TransformationDefinitionParameter {mappings::MappingTransformation.left = current}) ')'
	'(' (inModels+=TransformationDefinitionParameter) ')'
	'->'
	'(' outModels+=TransformationDefinitionParameter ')'

	(annotations+=Annotation)*

	(uses+=UsesStatements)*
	
	(delegates+=Delegate)*
	( contexts+=Context )+
    ;

// @common
Annotation returns core::Annotation:
	MetamodelModelAnnotation
;

MetamodelModelAnnotation returns core::MetamodelModelAnnotation:
	annotatedElement=[core::RepresentModel] ":" metamodel=STRING
;

UsesStatements returns core::UseDeclaration: 
	UseDeclaration // TODO: Allow several declarations together
;

UseDeclaration returns core::UseDeclaration: 
	"uses" module=EString ("as" ^as=EString)?
;

TransformationDefinitionParameter returns core::TransformationDefinitionParameter:
	{core::TransformationDefinitionParameter}
	name=EString
	;
	
/*
ClassUse returns core::ClassUse :
	model=[core::RepresentModel] "!" className=ID	
;
*/
// Using Expressions as superlanguage makes that [a] does not work because of conflicts
	
// end-of-common


Delegate returns mappings::Delegate :
	(tags += Tag)*	
	"delegate" "from" left+=MatchedElement ( "," left+=MatchedElement)*  
	      'to' ( module=[core::UseDeclaration] isExternal?="!") linkName=EString ("." featureName=EString)?
	;


Context returns mappings::Context :
	(tags += Tag)*
	"from" left+=MatchedElement ( "," left+=MatchedElement)*  'to' right+=MatchedElement ( "," right+=MatchedElement)*	
    	(modifiers+=C2CModifier)*
		// (mappings += (Attribute2Attribute | AttributeIsString | Reference2Reference) )*
		(mappings += (AttributeMapping | Reference2Reference) )*
	"end"
	;

Tag returns mappings::Tag: 
	"[" name=EString "]"
;


MatchedElement returns mappings::MatchedElement: 
	(name=ID ":")? model=[core::RepresentModel] "!" className=ID	
	(annotations+=SingleAnnotation)? (strictType ?= "!")?
;

SingleAnnotation returns core::SingleAnnotation :
	PotencyAnnotation
;

PotencyAnnotation returns core::PotencyAnnotation: 
	("@" | "^") value=INT
; // copied from expressions


C2CModifier returns mappings::C2CModifier: 
	LinkedBy
;

// linking cd.originalCompilationUnit = cu
LinkedBy returns mappings::LinkedBy: 
	"linking" attribute=AttributeRef "=" linkedElement=[mappings::MatchedElement]	
;

/*
Attribute2Attribute returns mappings::Attribute2Attribute :
   left+=AttributeRef ( "," left+=AttributeRef)*  '=' right+=AttributeRef ( "," right+=AttributeRef)*
   (converter=Converter)?	
;	

AttributeIsString returns mappings::AttributeIsString :
   left+=AttributeRef '=' strValue=EString
;
*/	

AttributeMapping returns mappings::AttributeMapping :
	left+=AttributeRef ( "," left+=AttributeRef)*  '=' rightPart=AttributeRightPart
;

AttributeRightPart returns mappings::AttributeRightPart:
	AttributeIsString 
	| AttributeIsBoolean	
	| AttributeIsDouble	
	| AttributeIsInteger
	| Attribute2Attribute	

;


Attribute2Attribute returns mappings::Attribute2Attribute :
   right+=AttributeRef ( "," right+=AttributeRef)*
   (converter=Converter)?	
;	

AttributeIsString returns mappings::AttributeIsString :
   strValue=StrictString
;

AttributeIsBoolean returns mappings::AttributeIsBoolean :
   boolValue=EBoolean
;

AttributeIsDouble returns mappings::AttributeIsDouble :
   doubleValue=EDouble
;

AttributeIsInteger returns mappings::AttributeIsInteger :
   intValue=EInt
;

AttributeRef returns mappings::AttributeRef : 
	(referredElement=[mappings::MatchedElement]	 '.')? featureName = EString (multivalued?="*")?
	;

Reference2Reference returns mappings::Reference2Reference :
   left+=ReferenceRef ( "," left+=ReferenceRef)*  '<-' right+=ReferenceRef ( "," right+=ReferenceRef)*	
	(converter=Converter)?	
;	

ReferenceRef returns mappings::ReferenceRef : 
	(referredElement=[mappings::MatchedElement] '.')? featureName=EString (multivalued?="*")?
	;

Converter returns mappings::Converter: 
	"convert" (module=[core::UseDeclaration] isExternal?=".")? converterName=EString
;


// Not sure if this has be factorized somewhere...
EString returns ecore::EString:
	STRING | ID;

EDouble returns ecore::EDouble : INT '.' INT;

EBoolean returns ecore::EBoolean:
	"true" | "false";
	
StrictString returns ecore::EString:
	STRING;

EInt returns ecore::EInt:
	'-'? INT;

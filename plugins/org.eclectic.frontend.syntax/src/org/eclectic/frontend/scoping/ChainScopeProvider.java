/*
 * generated by Xtext
 */
package org.eclectic.frontend.scoping;

import java.util.HashMap;

import org.eclectic.frontend.chain.ChainFactory;
import org.eclectic.frontend.chain.ChainTransformation;
import org.eclectic.frontend.chain.CompositeTransformation;
import org.eclectic.frontend.chain.ExternalTransformation;
import org.eclectic.frontend.chain.GeneratedModel;
import org.eclectic.frontend.chain.TransformationExecution;
import org.eclectic.frontend.core.CoreFactory;
import org.eclectic.frontend.core.ImportedModel;
import org.eclectic.frontend.core.InlineModel;
import org.eclectic.frontend.core.TransformationDefinition;
import org.eclectic.frontend.core.TransformationDefinitionParameter;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class ChainScopeProvider extends AbstractDeclarativeScopeProvider {

	public IScope scope_TransformationExecution_transformation(TransformationExecution this_, EReference ref) {
		return new ChainScope4Transformations(this_);
	}
	
	public IScope scope_TransformationExecution_inputModels(TransformationExecution this_, EReference ref) {
		return new InModelScope4Transformations(this_);
	}

	public IScope scope_TransformationExecution_outputModels(TransformationExecution this_, EReference ref) {
		return new OutModelScope4Transformations(this_);
	}
	
	// TODO: En cada recompilaci√≥n hay que eliminar los externals que no valgan... dificil!

	class OutModelScope4Transformations implements IScope {

		private TransformationExecution obj;

		public OutModelScope4Transformations(TransformationExecution t) {
			this.obj = t;
		}
		
		protected IEObjectDescription getOutModel(TransformationDefinition t, String name) {
			for(TransformationDefinitionParameter model : t.getOutModels()) {
				if ( model.getName().equals(name) ) {
					return EObjectDescription.create(name, model);
				}
			}
			if ( t.eContainer() != null ) {
				return getOutModel((TransformationDefinition) t.eContainer(), name);
			}
			return null;
		}
		
		@Override
		public IEObjectDescription getSingleElement(QualifiedName name) {
			IEObjectDescription result = getOutModel((TransformationDefinition) obj.eContainer(), name.getFirstSegment());
			if ( result != null ) return result;
			
			// TODO: REVIEW THIS STRATEGY BECAUSE THIS WORKS FOR COMPOSITE, BUT FOR A CHAIN THIS MEANS
			//       THAT TWO TRANSFORMATIONS GENERATE THE SAME MODEL...
			ChainTransformation t = (ChainTransformation) EcoreUtil.getRootContainer(obj);
			for(GeneratedModel generated : t.getGeneratedModels()) {
				if ( generated.getName().equals(name.getFirstSegment()) ) {
					return EObjectDescription.create(name.getFirstSegment(), generated);
				}
			}
			
			
			GeneratedModel g = ChainFactory.eINSTANCE.createGeneratedModel();
			g.setName(name.getFirstSegment());
			t.getGeneratedModels().add(g);
			
			return EObjectDescription.create(g.getName(), g);
		}

		@Override
		public Iterable<IEObjectDescription> getElements(QualifiedName name) {
			return null;
		}

		@Override
		public IEObjectDescription getSingleElement(EObject object) {
			return null;
		}

		@Override
		public Iterable<IEObjectDescription> getElements(EObject object) {
			return null;
		}

		@Override
		public Iterable<IEObjectDescription> getAllElements() {
			return null;
		}
	}

	class InModelScope4Transformations implements IScope {
		private TransformationExecution obj;

		public InModelScope4Transformations(TransformationExecution t) {
			this.obj = t;
		}
		
		protected IEObjectDescription getInModel(TransformationDefinition t, String name) {
			for(TransformationDefinitionParameter model : t.getInModels()) {
				if ( model.getName().equals(name) ) {
					return EObjectDescription.create(name, model);
				}
			}
			if ( t.eContainer() != null ) {
				return getInModel((TransformationDefinition) t.eContainer(), name);
			}
			return null;
		}
		
		@Override
		public IEObjectDescription getSingleElement(QualifiedName name) {
			IEObjectDescription r = getInModel((TransformationDefinition) obj.eContainer(), name.getFirstSegment());
			if ( r != null ) return r;
			
			// Try to see if there is a link from a generated model passed as parameter

			ChainTransformation t = (ChainTransformation) EcoreUtil.getRootContainer(obj);
			for(GeneratedModel generated : t.getGeneratedModels()) {
				if ( generated.getName().equals(name.getFirstSegment()) ) {
					return EObjectDescription.create(name.getFirstSegment(), generated);
				}
			}

			return null;
		}

		@Override
		public Iterable<IEObjectDescription> getElements(QualifiedName name) {
			return null;
		}

		@Override
		public IEObjectDescription getSingleElement(EObject object) {
			return null;
		}

		@Override
		public Iterable<IEObjectDescription> getElements(EObject object) {
			return null;
		}

		@Override
		public Iterable<IEObjectDescription> getAllElements() {
			return null;
		}
	}
	
	class ChainScope4Transformations implements IScope {

		private TransformationExecution obj;

		public ChainScope4Transformations(TransformationExecution t) {
			this.obj = t;
		}
		
		@Override
		public IEObjectDescription getSingleElement(QualifiedName name) {
			// TODO: MOVE THIS TO A POST-PROCESSING STEP IN THE PARSER
			ChainTransformation t = (ChainTransformation) EcoreUtil.getRootContainer(obj);
			for(CompositeTransformation composite : t.getComposites()) {
				if ( composite.getName().equals(name.getFirstSegment()) ) {
					return EObjectDescription.create(composite.getName(), composite);
				}
			}
			
			ExternalTransformation found = null;
			for(ExternalTransformation external : t.getExternals()) {		
				if ( external.getName().equals(name.getFirstSegment()) ) {
					found = external;
					break;
				}
			}
			
			if ( found == null ) {
				found = ChainFactory.eINSTANCE.createExternalTransformation();
				found.setName(name.getFirstSegment());
				t.getExternals().add(found);
			}
			return EObjectDescription.create(found.getName(), found);
		}
	
		@Override
		public Iterable<IEObjectDescription> getElements(QualifiedName name) {
			throw new UnsupportedOperationException();
		}
	
		@Override
		public IEObjectDescription getSingleElement(EObject object) {
			throw new UnsupportedOperationException();
		}
	
		@Override
		public Iterable<IEObjectDescription> getElements(EObject object) {
			throw new UnsupportedOperationException();
		}
	
		@Override
		public Iterable<IEObjectDescription> getAllElements() {
			throw new UnsupportedOperationException();
			//return models.values();
			// return null;
		}	
	}	

}
